---
id: 347
title: 'FLP and CAP aren&#8217;t the same thing'
date: 2012-03-25T20:55:34+00:00
author: Henry
layout: post
guid: http://the-paper-trail.org/blog/?p=347
permalink: /flp-and-cap-arent-the-same-thing/
categories:
  - Distributed systems
---
An [interesting question](http://www.quora.com/Distributed-Systems/Are-the-FLP-impossibility-result-and-Brewers-CAP-theorem-basically-equivalent) came up on [Quora](http://www.quora.com) this last week. Roughly speaking, the question asked how, if at all, the [FLP](http://the-paper-trail.org/blog/?p=49) theorem and the [CAP theorem](http://the-paper-trail.org/blog/?p=290) were related. I&#8217;d thought idly about exactly the same question myself before. Both theorems concern the impossibility of solving fairly similar fundamental distributed systems problems in what appear to be fairly similar distributed systems settings. The CAP theorem gets all the airtime, but FLP to me is a more beautiful result. Wouldn&#8217;t it be fascinating if both theorems turned out to be equivalent; that is effectively restatements of each other?

<!--more-->

> #### What the two theorems mean
> 
> The **FLP theorem** states that in an asynchronous network where messages may be delayed but not lost, there is no consensus algorithm that is guaranteed to terminate in every execution for all starting conditions, if at least one node may fail-stop.</strong>
> 
> The **CAP theorem** states that in an asynchronous network where messages may be lost, it is impossible to implement a sequentially consistent atomic read / write register that responds eventually to every request under every pattern of message loss.</ul> 

Without ever having tackled the problem formally, I had speculated that they might be equivalent, based on a few observations. First, consensus and serialisable atomic objects are very closely related. Both involve causing a set of nodes to come to some agreement about shared state. In the case of consensus, it&#8217;s the value proposed, in the case of atomic objects it&#8217;s the order and identity of any operations performed. Secondly, the failure modes in both theorems appeared similar. CAP deals with &#8216;partitions&#8217;, which is the non-delivery of a subset of messages, and FLP deals with &#8216;faulty nodes&#8217;, which are nodes that only take a finite number of steps in any execution, steps which include message receipt. It seemed likely that both failure models could be used to describe the other. Thirdly, both problems deal with safety and liveness properties in distributed systems in the context of failures. 

I wrote an answer up quickly to the question, and formulated a proof sketch typical for these kind of questions: if two problems are equivalent, then a solution to one is a solution to the other, and vice versa. My answer was, like so many informal arguments of this nature, concise, convenient, convincing and wrong.

### The Importance Of Context

[Emin Gun Sirer](http://www.cs.cornell.edu/people/egs/) pointed out was what wrong with my argument. One direction of the equivalence still looks good &#8211; a solution to CAP could be used to formulate a solution to the FLP problem. The problem is in the other direction &#8211; with my assertion that an FLP solution could be used to solve CAP. The distinction arises when we consider how each theorem treats nodes that aren&#8217;t receiving the messages that are being sent to them. In FLP, such nodes are failed, and exempt from having to achieve consensus. In CAP, such nodes are only partitioned. Here&#8217;s the difference: a CAP solution requires that any live node be able to correctly serve requests, _even if it has not received any messages_. So a partitioned node in FLP does _not_ have to achieve consensus, since it is considered failed, but the same node in CAP must &#8211; somehow &#8211; keep up with the activity of the rest of the system.

To reinforce this point, let&#8217;s take a look at how [Gilbert and Lynch](http://dl.acm.org/citation.cfm?id=564601) proved their formalisation of the CAP theorem. They show a simple, intuitive result. If there is a permanent partition between two disjoint subsets of nodes in the system, call them  <img src='http://s0.wp.com/latex.php?latex=G_1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_1' title='G_1' class='latex' />and <img src='http://s0.wp.com/latex.php?latex=G_2&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_2' title='G_2' class='latex' />, then a write to  <img src='http://s0.wp.com/latex.php?latex=G_2&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_2' title='G_2' class='latex' />can never cause any different execution to occur in  <img src='http://s0.wp.com/latex.php?latex=G_1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_1' title='G_1' class='latex' />(because the only way that  <img src='http://s0.wp.com/latex.php?latex=G_2&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_2' title='G_2' class='latex' />can influence  <img src='http://s0.wp.com/latex.php?latex=G_1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_1' title='G_1' class='latex' />is to send a message). But  <img src='http://s0.wp.com/latex.php?latex=G_1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_1' title='G_1' class='latex' />might have to respond to a read request **after** the initial write to <img src='http://s0.wp.com/latex.php?latex=G_2&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_2' title='G_2' class='latex' />. To be sequentially consistent,  <img src='http://s0.wp.com/latex.php?latex=G_1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G_1' title='G_1' class='latex' />must return the value of the write. It can&#8217;t, because it can never learn of the write. CAP does not identify partition with failure. FLP does, at least in the single node case.

This blows my argument out of the water, because I was relying on equal treatment of nodes that were completely partitioned from all others in both settings. But that&#8217;s not the case. So it is _not_ obvious that a solution to FLP can provide a solution to CAP.

### Proving Yourself Wrong

It would be unsatisfying only to establish that my original argument was flawed, because doing so doesn&#8217;t actually settle the original question: can CAP and FLP be considered equivalent? Instead of trying to prove the positive result, armed with a bit more clarity about the difference between the two theorems, let&#8217;s try and prove the negative; in particular that a solution to the FLP theorem will _not_ provide a solution to the CAP theorem.

A brief aside about the validity of this proof technique: you might reasonably be uncomfortable with me reasoning about &#8216;positive&#8217; solutions to the CAP or FLP theorem, since respected researchers have already established in peer reviewed articles that no solution to either exists. However, it&#8217;s still reasonable to effectively fantasise about what would be true _if_ positive solutions existed, and indeed it&#8217;s fundamental to posing questions about equivalence. To appeal to a more commonly considered problem &#8211; computer scientists spend a lot of time considering what would happen if a positive solution to  <img src='http://s0.wp.com/latex.php?latex=P+%3F%3D+NP&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='P ?= NP' title='P ?= NP' class='latex' />was found, even though it&#8217;s very possible (and usually considered likely) that no positive solution exists.

So let&#8217;s pretend we have this magical black box, which will provide a solution to the FLP problem. That is, if every node in the system runs the algorithm in this box, then non-trivial consensus will always be reached in finite time at all non-faulty nodes, even where there is a single faulty node in the system, under all initial conditions and all network behaviours. Could we use this algorithm to solve CAP?

To prove otherwise, we&#8217;re going to use a very similar argument to the one Gilbert and Lynch made, which is a proof by contradiction &#8211; we&#8217;re going to assume that the algorithm can solve CAP, and then show an example of where it could not.

In the following, I&#8217;m going to use &#8216;achieves consensus&#8217; as the target problem to solve. To do that, I need to quickly argue that any solution to consensus (ignoring the possibility of failures) can be used to implement an atomic sequentially consistent object. This is well established in the literature &#8211; the construction is called a _distributed finite state machine_. It works by having any node (i.e. one that receives a request) propose a value (i.e. the next write operation to execute, and its result). A round of consensus is performed, where the nodes either agree to the &#8216;next operation&#8217; proposal, or vote it down. If they vote it down, the proposer tries again. There are solutions (such as [Paxos](http://the-paper-trail.org/blog/?p=173)) which ensure that every valid proposal is eventually accepted. An object implemented in this way is necessarily sequentially consistent, since all requests are _ordered_ by the process of consensus deciding the next operation to execute. Read requests may be served locally without performing consensus, since all nodes know about the &#8216;most recent&#8217; write operation.

Let&#8217;s set up our network as follows. There will be one distinguished node, <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />, which is the &#8216;failing&#8217; node. It does not receive any messages from the rest of the system, and therefore takes a finite number of steps and then stops. We&#8217;ll call the rest of the network <img src='http://s0.wp.com/latex.php?latex=G+%3D+N+-+%5C%7BF%5C%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G = N - \{F\}' title='G = N - \{F\}' class='latex' />. In order to be a solution to CAP,  <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />must itself _decide_ on a value, since it may receive a read request to which it must respond in finite time. We&#8217;ll show that even with a solution to FLP, there must be some execution where  <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />does not know the right answer.

(Note &#8211; this is an extremely simple argument to make informally, but I&#8217;m hoping to show how one might think about this and more difficult problems more formally).

Imagine that a <tt>write(<img src='http://s0.wp.com/latex.php?latex=X&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='X' title='X' class='latex' />)</tt> operation is initiated by a client of some node in <img src='http://s0.wp.com/latex.php?latex=G&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G' title='G' class='latex' />, followed by read issued at <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />, all the time using the FLP algorithm we were given. Then, in order to be a correct CAP solution, F must respond to the read with the value <img src='http://s0.wp.com/latex.php?latex=X&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='X' title='X' class='latex' />. To do that, it takes some finite series of steps <img src='http://s0.wp.com/latex.php?latex=S%3DS_0%5Crightarrow+S_1%5Crightarrow+S_2%5Cdots%5Crightarrow+S_n&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='S=S_0\rightarrow S_1\rightarrow S_2\dots\rightarrow S_n' title='S=S_0\rightarrow S_1\rightarrow S_2\dots\rightarrow S_n' class='latex' />, and then takes no further action, because it is receiving no messages to spur it on.

Now imagine that instead, with the same exact initial conditions, a write(<img src='http://s0.wp.com/latex.php?latex=Y&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='Y' title='Y' class='latex' />) operation is initiated, again by a client of some node in <img src='http://s0.wp.com/latex.php?latex=G&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G' title='G' class='latex' />. Again, to be correct,  <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />must respond to a subequent read with the value <img src='http://s0.wp.com/latex.php?latex=Y&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='Y' title='Y' class='latex' />. To do so, it takes another series of steps <img src='http://s0.wp.com/latex.php?latex=T%3DT_0%5Crightarrow+T_1%5Crightarrow+T_2%5Cdots%5Crightarrow+T_n&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='T=T_0\rightarrow T_1\rightarrow T_2\dots\rightarrow T_n' title='T=T_0\rightarrow T_1\rightarrow T_2\dots\rightarrow T_n' class='latex' />. However,  <img src='http://s0.wp.com/latex.php?latex=T&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='T' title='T' class='latex' />and  <img src='http://s0.wp.com/latex.php?latex=S&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='S' title='S' class='latex' />_must be exactly the same sequence_. Why? Because the behaviour of a node is governed the algorithm it is executing, the initial conditions, and the messages it receives. The first two are exactly the same in both executions, and since no messages are being delivered, so is the third. Therefore, the value that  <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />has decided upon by the final step of both  <img src='http://s0.wp.com/latex.php?latex=T&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='T' title='T' class='latex' />and  <img src='http://s0.wp.com/latex.php?latex=S&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='S' title='S' class='latex' />must be the same value. But for correctness,  <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />is required to return _different_ values in each execution. This is a contradiction, hence the FLP-solving algorithm cannot be a solution to CAP, which was our initial assumption.

At this point you might be concerned &#8211; doesn&#8217;t FLP guarantee that all nodes agree on the same value? That is, if we had a magical FLP-solver, wouldn&#8217;t that guarantee that  <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />saw the same value as every other node in <img src='http://s0.wp.com/latex.php?latex=G&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='G' title='G' class='latex' />? The key observation here is that, from the perspective of FLP, _ <img src='http://s0.wp.com/latex.php?latex=F&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='F' title='F' class='latex' />has failed_. From the perspective of CAP, it has not, and must continue to participate correctly in certain activities of the system. So the algorithm is correctly solving consensus as defined by FLP, but the requirements of CAP are too strong.

If consensus cannot be achieved even with an FLP solution in CAP, we cannot use it to construct any kind of solution to CAP.

### What We Have Learnt

This result (if I&#8217;ve made no mistakes) is arguably more interesting than if the original equivalence assertion was true. To be an interesting impossibility result in distributed systems, it&#8217;s usually true that you want to place the fewest restrictions possible on the environment in which you&#8217;re establishing that result. The idea is that you give your result _every chance_ to be wrong, by allowing the environment few restrictions in the tricks it can pull to overcome the obstacles you&#8217;re constructing. Then, if your result _still_ turns out to be true, you know you have proved something really quite strong. (There way &#8216;strong&#8217; and &#8216;weak&#8217; are often used can be confusing &#8211; _weak_ assumptions lead to _strong_ impossibility results and vice versa).

So FLP, with its strictly weaker restrictions &#8211; all messages are eventually delivered, faulty nodes don&#8217;t have to achieve consensus &#8211; is by this definition a stronger result than CAP, which allows messages to be lost forever and forces partitioned nodes to participate in the system. It&#8217;s therefore much more surprising &#8211; and the authors in the [original paper](http://dl.acm.org/citation.cfm?id=214121) remark on this &#8211; because it&#8217;s so much more unexpected.

Conversely, CAP appears much more humdrum. Is it really surprising to anyone that it&#8217;s impossible to maintain sequentially consistent state in a distributed system if nodes cannot talk to each other? It&#8217;s not too far away from discussing what&#8217;s possible in a network that can experience total node failure &#8211; nothing at all, which is why all papers disregard it as a consideration. The utility of CAP comes from telling systems designers that they must be prepared to work in a world where availability or consistency are compromised, but is rather cataclysmic about the situations in which they might be threatened.

It would be more interesting to relax one or two assumptions &#8211; what if partitions are only temporary? What if we allow the client to participate (i.e. a client that has seen a write is allowed to convey that fact to a replica that it issues a read from)? What if partitioned nodes were excluded from participation? If we can show CAP to hold in these circumstances, it greatly restricts our ability to design correct, available systems that experience much weaker failures. _That_ would be interesting.