---
id: 211
title: 'Barbara Liskov&#039;s Turing Award, and Byzantine Fault Tolerance'
date: 2009-03-30T14:53:08+00:00
author: Henry
layout: post
guid: http://hnr.dnsalias.net/wordpress/?p=211
permalink: /barbara-liskovs-turing-award-and-byzantine-fault-tolerance/
categories:
  - computer science
  - Distributed systems
tags:
  - byzantine fault tolerance
  - consensus
  - Distributed systems
---
[Barbara Liskov](www.pmg.csail.mit.edu/~liskov/) has just been announced as the recipient of the [2008 Turing Award](http://www.acm.org/press-room/news-releases/turing-award-08/), which is one of the most important prizes in computer science, and can be thought of as our field&#8217;s equivalent to the various Nobel Prizes. Professor Liskov is a worthy recipient of the award, even if judged alone by her [citation](http://awards.acm.org/citation.cfm?id=1108679&srt=all&aw=140&ao=AMTURING) which lists a number of the important contributions she has made to operating systems, programming languages and distributed systems.

Professor Liskov seems to be particularly well known for the [Liskov substitution principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle) which says that some property of a supertype ought to hold of its subtypes. I&#8217;m not in any position to speak as to the importance of this contribution. However, her more recent work has been regarding the tolerance of Byzantine failures in distributed systems, which is much more close to my heart.

The only work of Liskov&#8217;s that I am really familiar with is the late 90s work on [Practical Byzantine Fault Tolerance](http://www.pmg.lcs.mit.edu/~castro/osdi99_html/osdi99.html) with [Miguel Castro](http://research.microsoft.com/en-us/um/people/mcastro/) and is first published in [this OSDI &#8217;99 paper](http://www.pmg.lcs.mit.edu/papers/osdi99.pdf). I&#8217;m not going to do a full review, but the topic sits so nicely with my recent focus on consensus protocols that it makes sense to briefly discuss its importance.
  
<!--more-->

## Towards Byzantium

Remember that in the articles on [Paxos](http://hnr.dnsalias.net/wordpress/?p=173), we were able to deal with two kinds of failure: fail-stop and fail-recover. Although these two failure modes capture a lot of the possible failures in a distributed system there is a yet more general failure mode which captures all possible kinds of errors. _Byzantine failures_ occur when a participant in a protocol deviates arbitrarily from the specified protocol, and thus cannot be relied upon to do anything useful. Worse than that, Byzantine nodes may often look like they are non-faulty up until a crucial point where they might, for example, lie about the result of a transaction, or send two different responses to identical requests, or simply fail to respond. Although Byzantine failures are often equated with malicious attacks, where an attacker has gained control of a node and is controlling its behaviour, in fact many Byzantine failures occur due to programming errors in the implementation of a protocol (Amazon were susceptible to a Byzantine failure recently when a bit-flip caused a gossipped message to be incorrectly propogated, [taking down S3 for hours](http://status.aws.amazon.com/s3-20080720.html)).

As we&#8217;ve talked about elsewhere on this blog, consensus is a hugely important primitive for distributed algorithms. When Byzantine failures come into the picture consensus takes even more of the centre stage. Every action that a replica is instructed to perform has to be validated by every fault-free replica because there&#8217;s a strong possibility that the coordinator is itself faulty and has told different nodes to do different things. So nodes must run a consensus protocol to agree on what they were asked to do, let alone the result of doing it.

Of course, standard consensus algorithms won&#8217;t do as they themselves are not Byzantine fault tolerant. So building Byzantine fault tolerant systems is often reduced to building a Byzantine fault tolerant consensus primitive, and using that to build replicated state machines in the usual style.

When we talk about BFT consensus we often distinguish a _co-ordinator_ node responsible for initiating the consensus protocol and proposing the initial value, which is usually received from an external client. The other nodes are replicas, as normal. There&#8217;s nothing particularly special about the co-ordinator, as it still functions like a replica for the rest of the protocol. However, we can show that if the co-ordinator is definitely not faulty then we can execute a more relaxed protocol; more on this later.

BFT consensus has similar requirements to standard consensus: validity, which is that only a proposed value can be decided upon, termination and agreement. Agreement says that all correct nodes must agree upon the same value &#8211; this is the same as for standard consensus, but the definition of faulty here is widened to include Byzantine faults. Validity also requires a small relaxation &#8211; if the co-ordinator is faulty then we allow correct nodes to agree upon some default &#8216;no-op&#8217; value. This is because if the co-ordinator is faulty it&#8217;s impossible to tell what the original request from the client was, and so the safe action is to do nothing. If the co-ordinator is non-faulty, then validity is required as normal. This of course implies that correct replicas must be able to detect a faulty co-ordinator.

How might faults appear in an instance of Byzantine consensus? There are the standard failure modes that we know about &#8211; messages might take a long time to be processed, due to a fail-recover fault, or replicas might crash. More perniciously, replicas might falsify messages to other replicas. The co-ordinator might tell half the replicas that value A has been proposed, and half the replicas that value B was. Faulty replicas in either half might then lie to other replicas about the value that it received from the co-ordinator. The task of a Byzantine fault-tolerant consensus algorithm is to figure out if the co-ordinator is non-faulty, and if so what values it sent to the good replicas. This is a difficult problem &#8211; how, with no a priori notion of trust, do you tell who is lying?

[Leslie Lamport](http://research.microsoft.com/en-us/um/people/lamport/), along with Shostak and Pease, wrote [the seminal paper on the subject of BFT](http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#byz). Indeed, they introduced the metaphor of the &#8216;Byzantine Generals&#8217;, deciding whether to attack or retreat from their distributed camp sites in the presence of potential traitors, and therefore misinformation.

Their paper set out two important results. The first is the most well known: that to tolerate completely arbitrary Byzantine failures in a network where Byzantine replicas may lie not only about their own state, but what they have heard from other replicas, at least  <img src='http://s0.wp.com/latex.php?latex=3f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='3f+1' title='3f+1' class='latex' />nodes total are required to tolerate  <img src='http://s0.wp.com/latex.php?latex=f&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='f' title='f' class='latex' />faults.

This is an extremely famous result, and one that is quoted time and time again in the literature &#8211; often without a full understanding of why it holds and in what conditions. The proof itself will be the subject of a later post, but the intuition comes from considering the  <img src='http://s0.wp.com/latex.php?latex=2f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='2f+1' title='2f+1' class='latex' />case when <img src='http://s0.wp.com/latex.php?latex=f%3D1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='f=1' title='f=1' class='latex' />. In order to reach agreement with three nodes, it can be seen very easily that every replica must send every other replica a message containing the proposal it got from the co-ordinator. If only the co-ordinator could be faulty then the replicas can figure this out very quickly as, when they compare notes, they will see that both received different proposals. However, if one of the replicas could be faulty then the good replica will still see the same message from the faulty replica: both values that they claim to have received from the co-ordinator are different. Since the good replica can&#8217;t distinguish this situation from when the co-ordinator is faulty, it can&#8217;t decide who to believe and therefore can&#8217;t decide consistently. The paper then goes on to show that any purported solution which uses fewer than  <img src='http://s0.wp.com/latex.php?latex=3f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='3f+1' title='3f+1' class='latex' />replicas could be used to solve the three-replica, one fault case. Therefore, any correct solution must involve  <img src='http://s0.wp.com/latex.php?latex=3f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='3f+1' title='3f+1' class='latex' />replicas or more. The paper gives one such solution.

The second result is that, if nodes may sign their messages to other nodes in a non-forgeable way so that Byzantine nodes cannot lie about what they have heard, there is an algorithm for Byzantine consensus in a synchronous network that tolerates  <img src='http://s0.wp.com/latex.php?latex=f+%3D+n-2&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='f = n-2' title='f = n-2' class='latex' />failures. This is dramatically better than the  <img src='http://s0.wp.com/latex.php?latex=3f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='3f+1' title='3f+1' class='latex' />bound, but comes at the cost of an expensive protocol in terms of the number of rounds needed to execute.

It&#8217;s difficult to overestimate how influential this paper has been. All subsequent BFT papers that I&#8217;ve read (quite a few!) have characterised their solutions similarly, in terms of the fraction of faulty replicas that their algorithm will tolerate. The idea of having replicas sign their messages, so that other replicas could not lie about what they had heard is highly practical given the advent of public-key cryptography, and clearly greatly strengthens the system.

But Lamport&#8217;s paper only dealt with synchronous signed-message networks. What about asynchronous ones? Treatment of these had to wait until a few years later for a paper by Bracha and Toueg. They showed that, even if replicas could not forge responses from other replicas, there was still a fundamental  <img src='http://s0.wp.com/latex.php?latex=3f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='3f+1' title='3f+1' class='latex' />lower bound on the number of replicas. The proof was by construction of an arrangement of replicas such that correct replicas couldn&#8217;t decide between good and bad responses under two different, but identical from the perspective of correct replicas, executions.

The intuition behind this result is that each correct replica must hear from  <img src='http://s0.wp.com/latex.php?latex=2f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='2f+1' title='2f+1' class='latex' />other replicas in the worst case, so that the  <img src='http://s0.wp.com/latex.php?latex=f&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='f' title='f' class='latex' />faulty replicas that may be lying about the proposed value that they heard can be outvoted. So the number of replicas must be at least <img src='http://s0.wp.com/latex.php?latex=r+%5Cgeq+2f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='r \geq 2f+1' title='r \geq 2f+1' class='latex' />.

At the same time, a replica can only wait to hear from at most  <img src='http://s0.wp.com/latex.php?latex=n-f&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='n-f' title='n-f' class='latex' />replicas (where  <img src='http://s0.wp.com/latex.php?latex=n&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='n' title='n' class='latex' />is the total number of replicas). Why? Because in an asynchronous system it&#8217;s possible either that a)  <img src='http://s0.wp.com/latex.php?latex=f&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='f' title='f' class='latex' />replicas are faulty and have failed to reply or b)  <img src='http://s0.wp.com/latex.php?latex=f&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='f' title='f' class='latex' />replicas are _not faulty_, but _haven&#8217;t replied yet_. A correct replica can&#8217;t distinguish between these cases, and so can&#8217;t wait for an unbounded amount of time to get all  <img src='http://s0.wp.com/latex.php?latex=n&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='n' title='n' class='latex' />replies, which might never be forthcoming. If the network were synchronous, a good replica could detect that the  <img src='http://s0.wp.com/latex.php?latex=f&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='f' title='f' class='latex' />replicas that had failed to reply must be faulty, which means that the replies it had already received were all from the other correct replicas. In an asynchronous network, this is not possible.

Therefore we have that <img src='http://s0.wp.com/latex.php?latex=n+-f+%5Cgeq+r+%5Cgeq+2f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='n -f \geq r \geq 2f+1' title='n -f \geq r \geq 2f+1' class='latex' />, or that <img src='http://s0.wp.com/latex.php?latex=n+%5Cgeq+3f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='n \geq 3f+1' title='n \geq 3f+1' class='latex' />.

## Practical Byzantine Fault Tolerance

Miguel Castro and Professor Liskov had a 1999 OSDI paper called [Practical Byzantine Fault Tolerance](). Their contribution was to develop a Byzantine fault tolerant consensus protocol that was both efficient and applicable to realistic scenarios.

Liskov and Castro were the first to propose a correct algorithm that worked efficiently in asynchronous networks, and that realised the  <img src='http://s0.wp.com/latex.php?latex=3f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='3f+1' title='3f+1' class='latex' />lower bound. [FLP impossibility](http://hnr.dnsalias.net/wordpress/?p=49) tells us that consensus is in general impossible to solve in asynchronous networks with even just fail-stop failures, rather than the more general Byzantine failures, so Liskov and Castro&#8217;s PBFT took a similar approach to [Paxos](http://hnr.dnsalias.net/wordpress/?p=173) and guaranteed liveness only when the network was synchronous. During periods of asynchrony PBFT may not terminate, but will never violate its safety properties (which are, as ever, validity and agreement).

PBFT&#8217;s other advantages were its high performance &#8211; owing in part to the use of the more efficient [Message Authentication Codes](http://en.wikipedia.org/wiki/Message_authentication_code) rather than public-key cryptography for fast message signing &#8211; and its ability to tolerate an unbounded number of faults over the lifetime of execution, as long as no more than  <img src='http://s0.wp.com/latex.php?latex=f&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='f' title='f' class='latex' />were concurrent. PBFT provides the familiar state-machine abstract interface, with a primary through which requests go that proposes a sequence number for every operation. The correct replicas agree (via Byzantine consensus) on the sequence number, and then commit the requests in sequence order.

The protocol itself is reasonably simple, but I&#8217;m not going to describe it in detail here as that would require a lot of groundwork to prove some basic results and show why it&#8217;s correct: this will be the subject of a future series of posts, as there&#8217;s a lot of [interesting work in BFT still being done](http://research.microsoft.com/apps/pubs/default.aspx?id=72404). The basic idea of PBFT is to have the primary broadcast a request to all replicas, which then retransmit what they have heard to every other replica. If all replicas agree on the same operation, then the primary is currently correct, and the replicas broadcast a commit message to each other, much like a standard three-phase commit protocol. In fact, replicas will proceed once they have got  <img src='http://s0.wp.com/latex.php?latex=2f%2B1&#038;bg=ffffff&#038;fg=000000&#038;s=0' alt='2f+1' title='2f+1' class='latex' />identical replies in the first phase, which is a [Byzantine quorum](), any two of which will be guaranteed to contain at least one correct replica in common. The idea is to ensure that the primary can&#8217;t have two conflicting sequence numbers for a single request accepted (since this would require a correct replica to accept both, which it will not do).

If, however, the primary turns out to be faulty, then a _view-change_ protocol has to be executed, which causes all replicas to stop taking requests from the primary, and elect a new one in its stead. Getting this protocol right involves taking checkpoints of mutually agreed upon histories, since a view-change might occur during a request, then agreeing on the new leader and restarting any pending requests. All the while making sure that faulty replicas can&#8217;t hijack the process.

If you&#8217;re interested, the best paper is not the OSDI one, but the one in [Transactions on Computer Systems](http://research.microsoft.com/en-us/um/people/mcastro/publications/p398-castro-bft-tocs.pdf), which is a longer paper and an easier read.

PBFT has since been update by a variety of different work, but the main structure of the protocol has yet to be fundamentally improved upon. There is still some distance to go before Byzantine fault tolerance techniques habitually make their way into production systems &#8211; there&#8217;s still increased complexity, cost and performance issues to worry about &#8211; but when they do, PBFT will doubtless have been a tremendously important step in the right direction.